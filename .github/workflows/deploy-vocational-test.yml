name: Deploy Vocational Test to K3S

on:
  workflow_call:
    inputs:
      image-tag:
        description: 'Image tag (e.g., main-abc1234)'
        required: true
        type: string
  
  workflow_dispatch:
    inputs:
      image-tag:
        description: 'Image tag from GestPro-VocationalTest (e.g., main-abc1234)'
        required: true
        type: string

jobs:
  validate:
    name: Validate Manifests
    runs-on: self-hosted
    steps:
      - name: Checkout infra manifests
        uses: actions/checkout@v4

      - name: Install kubeval
        run: |
          mkdir -p /tmp/kubeval
          wget -q https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz -O - | tar xz -C /tmp/kubeval
          echo "/tmp/kubeval" >> $GITHUB_PATH

      - name: Validate YAML syntax
        run: |
          echo "Validating Vocational_Test manifests..."
          kubeval Vocational_Test/*.yaml --ignore-missing-schemas || true
          echo "‚úì YAML validation passed"

      - name: Install yamllint
        run: pip install yamllint

      - name: Lint YAML
        run: |
          echo "Linting YAML files..."
          yamllint Vocational_Test/ || true
          echo "‚úì YAML lint completed"

  deploy:
    name: Deploy to K3S
    runs-on: self-hosted
    environment: vocational-test
    needs: validate
    
    steps:
      - name: Checkout infra manifests
        uses: actions/checkout@v4

      - name: Setup kubeconfig
        env:
          KUBECONFIG_B64: ${{ secrets.KUBECONFIG_B64 }}
        run: |
          if [ -z "$KUBECONFIG_B64" ]; then
            echo "‚ùå Error: KUBECONFIG_B64 secret not configured"
            exit 1
          fi
          
          echo "$KUBECONFIG_B64" | base64 -d > /tmp/kubeconfig
          chmod 600 /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          
          echo "‚úì Kubeconfig ready"
          kubectl cluster-info | head -3

      - name: Verify K3S connectivity
        env:
          KUBECONFIG: /tmp/kubeconfig
        run: |
          echo "Checking K3S cluster..."
          kubectl get nodes
          echo "‚úì Cluster connectivity verified"

      - name: Create namespace
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
        run: |
          kubectl create namespace $KUBE_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úì Namespace '$KUBE_NAMESPACE' ready"

      - name: Create app secrets
        env:
          KUBECONFIG: /tmp/kubeconfig
          ORACLE_USER: ${{ secrets.ORACLE_USER }}
          ORACLE_PASSWORD: ${{ secrets.ORACLE_PASSWORD }}
          ORACLE_CONNECTION_STRING: ${{ secrets.ORACLE_CONNECTION_STRING }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          OCI_PREAUTH_URL_READ: ${{ secrets.OCI_PREAUTH_URL_READ }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
        run: |
          echo "Creating secrets..."
          
          kubectl create secret generic vocational-test-secrets \
            --from-literal=ORACLE_USER="$ORACLE_USER" \
            --from-literal=ORACLE_PASSWORD="$ORACLE_PASSWORD" \
            --from-literal=ORACLE_CONNECTION_STRING="$ORACLE_CONNECTION_STRING" \
            --from-literal=GROQ_API_KEY="$GROQ_API_KEY" \
            --from-literal=OCI_PREAUTH_URL_READ="$OCI_PREAUTH_URL_READ" \
            --from-literal=OCI_PREAUTH_URL_WRITE="$OCI_PREAUTH_URL_WRITE" \
            --from-literal=SECRET_KEY="$SECRET_KEY" \
            -n $KUBE_NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úì Secrets created"

      - name: Apply manifests
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
        run: |
          echo "Applying Vocational_Test manifests..."
          kubectl apply -f Vocational_Test/ -n $KUBE_NAMESPACE
          echo "‚úì Manifests applied"

      - name: Determine image tag
        id: image-tag
        run: |
          # Para reusable workflow (workflow_call)
          TAG="${{ inputs.image-tag }}"
          
          # Fallback para workflow_dispatch
          if [ -z "$TAG" ]; then
            TAG="${{ github.event.inputs.image-tag }}"
          fi
          
          if [ -z "$TAG" ]; then
            echo "‚ùå No image tag provided"
            exit 1
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "üì¶ Image tag: $TAG"

      - name: Update deployment image
        env:
          KUBECONFIG: /tmp/kubeconfig
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
          REGISTRY: ${{ vars.REGISTRY }}
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          IMAGE="${REGISTRY}/${REPO_OWNER}/gestpro-vocationaltest:${IMAGE_TAG}"
          
          echo "Updating deployment image..."
          echo "   Image: $IMAGE"
          
          kubectl patch deployment/$KUBE_DEPLOYMENT \
            -p "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"vocational-test-app\",\"image\":\"$IMAGE\"}]}}}}" \
            -n $KUBE_NAMESPACE
          
          echo "‚úì Image updated"

      - name: Wait for rollout
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          echo "Waiting for rollout (timeout 5m)..."
          
          kubectl rollout status deployment/$KUBE_DEPLOYMENT \
            -n $KUBE_NAMESPACE \
            --timeout=5m || {
              echo "‚ùå Rollout failed, initiating rollback..."
              kubectl rollout undo deployment/$KUBE_DEPLOYMENT -n $KUBE_NAMESPACE
              exit 1
            }
          
          echo "‚úì Rollout completed successfully"

      - name: Wait for pod readiness
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          echo "Waiting for pods to be ready..."
          
          kubectl wait --for=condition=ready pod \
            -l app=$KUBE_DEPLOYMENT \
            -n $KUBE_NAMESPACE \
            --timeout=30s || {
              echo "‚ö†Ô∏è  Warning: Pods not ready yet, continuing with health check..."
            }
          
          sleep 2
          echo "‚úì Pods status checked"

      - name: Health check
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          echo "Running health checks..."
          
          # Get the first pod
          POD=$(kubectl get pod -l app=$KUBE_DEPLOYMENT -n $KUBE_NAMESPACE -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          
          if [ -z "$POD" ]; then
            echo "‚ö†Ô∏è  Warning: No pods found, skipping health check"
            exit 0
          fi
          
          echo "   Testing pod: $POD"
          
          # Port forward in background
          kubectl port-forward $POD 8000:8000 -n $KUBE_NAMESPACE > /dev/null 2>&1 &
          PF_PID=$!
          sleep 2
          
          # Health check
          HEALTH=$(curl -s -m 5 http://localhost:8000/health 2>/dev/null | jq -r '.status // "unknown"' 2>/dev/null)
          
          kill $PF_PID 2>/dev/null || true
          wait $PF_PID 2>/dev/null || true
          
          if [ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "ok" ]; then
            echo "‚úì Health check passed: $HEALTH"
          else
            echo "‚ö†Ô∏è  Health check returned: $HEALTH"
          fi

      - name: Verify deployment
        env:
          KUBECONFIG: /tmp/kubeconfig
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployment -n $KUBE_NAMESPACE
          
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n $KUBE_NAMESPACE -l app=$KUBE_DEPLOYMENT
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n $KUBE_NAMESPACE --sort-by='.lastTimestamp' | tail -10

      - name: Success notification
        if: success()
        env:
          KUBE_NAMESPACE: ${{ vars.KUBE_NAMESPACE }}
          KUBE_DEPLOYMENT: ${{ vars.KUBE_DEPLOYMENT }}
        run: |
          echo "‚úÖ Deployment successful!"
          echo ""
          echo "Summary:"
          echo "  Deployment: $KUBE_DEPLOYMENT"
          echo "  Namespace: $KUBE_NAMESPACE"
          echo "  Image tag: ${{ steps.image-tag.outputs.tag }}"
          echo "  Triggered by: ${{ github.event_name }}"
